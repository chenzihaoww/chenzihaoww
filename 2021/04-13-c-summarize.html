<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="cesarz">


<meta name="description" content="c++总结">
<meta name="keywords" content="c++">
<meta property="og:type" content="article">
<meta property="og:title" content="c++总结">
<meta property="og:url" content="www.cesarz.com.cn/2021/04-13-c-summarize.html">
<meta property="og:site_name" content="未来可期">
<meta property="og:description" content="c++总结">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-04-14T14:08:49.949Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c++总结">
<meta name="twitter:description" content="c++总结">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="未来可期" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.jpg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">


<title>c++总结 | 未来可期</title>

<script src="//cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script><!-- 百度推送 -->
<script>(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b08b02c0d38f252"></script>



    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?a7947eca286f16b0c7ae6bedffabf6b1";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


<script language="JavaScript">
    (function(window,document,undefined){
			var hearts = [];
			window.requestAnimationFrame = (function(){
				return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (callback){
					setTimeout(callback,3000/60);
				}
			})();
			init();
			function init(){
				css(".heart{width: 13px;height: 13px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
				attachEvent();
				gameloop();
			}
			function gameloop(){
				for(var i=0;i<hearts.length;i++){
					if(hearts[i].alpha <=0){
						document.body.removeChild(hearts[i].el);
						hearts.splice(i,1);
						continue;
					}
					hearts[i].y--;
					hearts[i].scale += 0.004;
					hearts[i].alpha -= 0.013;
					hearts[i].el.style.cssText = "left:"+hearts[i].x+"px;top:"+hearts[i].y+"px;opacity:"+hearts[i].alpha+";transform:scale("+hearts[i].scale+","+hearts[i].scale+") rotate(45deg);background:"+hearts[i].color;
				}
				requestAnimationFrame(gameloop);
			}
			function attachEvent(){
				var old = typeof window.onclick==="function" && window.onclick;
				window.onclick = function(event){
					old && old();
					createHeart(event);
				}
			}
			function createHeart(event){
				var d = document.createElement("div");
				d.className = "heart";
				hearts.push({
					el : d,
					x : event.clientX - 5,
					y : event.clientY - 5,
					scale : 1,
					alpha : 1,
					color : randomColor()
				});
				document.body.appendChild(d);
			}
			function css(css){
				var style = document.createElement("style");
				style.type="text/css";
				try{
					style.appendChild(document.createTextNode(css));
				}catch(ex){
					style.styleSheet.cssText = css;
				}
				document.getElementsByTagName('head')[0].appendChild(style);
			}
			function randomColor(){
				return "rgb("+(~~(Math.random()*255))+","+(~~(Math.random()*255))+","+(~~(Math.random()*255))+")";
			}
		})(window,document);
    
    </script>


</head>

<div class="player">
    <iframe scrolling="auto" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="https://music.163.com/outchain/player?type=0&amp;id=2271869985&amp;auto=0&amp;height=430"></iframe><br>
</div>
</html>

<body>

  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">cesarz</a></h1>
          <div>

              <span class=" icon-location-1"></span>
              <span class="author-location">WuHu, China</span>
          </div>
        </hgroup>
<br>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn" >
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>

                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3" >
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>

                </div>
                <div class="tips-box hide"  >
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner" >
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area" >
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/leave-message/">留言板</a></li>
                        
                            <li><a href="/about/">博客日志</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:760391159@qq.com" title="Email"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/qq_37867655" title="CSDN"></a>
                            
                                <a class="fa 网易云音乐" href="https://music.163.com/playlist?id=700838669&userid=469619340" title="网易云音乐"></a>
                            
                                <a class="fa QQ空间" href="https://user.qzone.qq.com/760391159" title="QQ空间"></a>
                            
                        </ul>
                    </nav>
                </section>

                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Competition/">Competition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashPump/">HashPump</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/V-REP/">V-REP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atom/">atom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-language/">c language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/case/">case</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/online-website/">online-website</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pycharm/">pycharm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql-injection/">sql-injection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlmap/">sqlmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新生/">新生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概率论/">概率论</a></li></ul>
                    </div>
                </section>
                

                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.cesarz.com.cn/about/">关于本站</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.ichunqiu.com/">i春秋</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://tongji.baidu.com/web/welcome/login">百度统计</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.shiyanbar.com/">实验吧</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976">腾讯云</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://mail.126.com/index.htm?">网易126邮箱</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.bmob.cn/">boom后端云</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.cslg.cn/">CSLG</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.bootcdn.cn">Bootstrap</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.umeng.com/">友盟</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <hr><div id="js-aboutme">格言：<div style="text-align:center;"><p>远方<br>是永远的期待<br>你的呼唤<br>就是我前行的号角</p></div>
                  <hr><p>邮箱：760391159@qq.com</p></div>
                </section>
                
            </div>
        </div>

    </header>

</div>


    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">cesarz</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">cesarz</a></h1>
              <div align="center">
                    <span class="icon-location-1"></span>
                      <span class="author-location">WuHu, China</span>
              </div>
            </hgroup>
            
            <!-- 
                <form id="search-form" align="center">
                <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
                <i class="fa fa-times" onclick="resetSearch()"></i>
                </form>
                <div id="local-search-result"></div>
                <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
             -->
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/leave-message/">留言板</a></li>
                
                    <li><a href="/about/">博客日志</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:760391159@qq.com" title="Email"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/qq_37867655" title="CSDN"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/playlist?id=700838669&userid=469619340" title="网易云音乐"></a>
                            
                                <a class="fa QQ空间" target="_blank" href="https://user.qzone.qq.com/760391159" title="QQ空间"></a>
                            
                        </ul>
            </nav>
        </header>
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>

      <div class="body-wrap"><article id="post-c-summarize" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/04-13-c-summarize.html" class="article-date">
      <time datetime="2021-04-13T06:01:43.000Z" itemprop="datePublished">2021-04-13</time>
</a>



    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      c++总结
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="面向对象和面向过程的设计的对比"><a href="#面向对象和面向过程的设计的对比" class="headerlink" title="面向对象和面向过程的设计的对比"></a>面向对象和面向过程的设计的对比</h2><table>
<thead>
<tr>
<th>项目名称</th>
<th>面向对象</th>
<th>面向过程（结构化设计）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>把整个需求按照特点、功能划分，将这些存在共性的部分封装成类（类实例化后才是对象），创建了对象不是为了完成某一个步骤，而是描述某个事物在解决问题的步骤中的行为</td>
<td>分析出解决问题所需要的步骤，然后用函数一步步的实现，实用的时候，一个个的一次调用即可</td>
</tr>
<tr>
<td>特点</td>
<td>封装、继承、多态</td>
<td>算法+数据结构</td>
</tr>
<tr>
<td>优势</td>
<td>适用于大型复杂系统，方便复用</td>
<td>适用于简单系统，容易理解</td>
</tr>
<tr>
<td>劣势</td>
<td>比较抽象</td>
<td>难以应对复杂系统，难以复用</td>
</tr>
<tr>
<td>设计语言</td>
<td>java,c++,c#,python等</td>
<td>c</td>
</tr>
</tbody></table>
<p>例如：五子棋的设计。面向过程是首先分析问题的步骤：1.开始游戏 2.黑子先走 3.绘制图画等等，最后输出结果，将对应的步骤分函数实现即可。</p>
<p>面向对象是：整个五子棋可以分为：1.黑白双方，行为是一样的 2.棋盘系统，负责绘制画面 3.规则系统，负责判断犯规，输赢等。玩家对象负责接收用户输入，并告知棋盘对象棋子的布局的变化，棋盘对象接收到了棋子的变化负责在屏幕上显示这种变化，同时用规则系统判定。 </p>
<h2 id="面向对象的程序设计的基本特征"><a href="#面向对象的程序设计的基本特征" class="headerlink" title="面向对象的程序设计的基本特征"></a>面向对象的程序设计的基本特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将有关的数据和操作代码封装在一个对象中，形成一个基本单位，各个对象之间相互独立，互不干扰。用户对不同的数据有不同的权限，既降低了操作对象的复杂程度，又使安全性大大增加。</p>
<p>意义：</p>
<ul>
<li>将属性和行为作为整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    访问权限：属性/行为</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>描述类之间的关系。子类具有父类（基类）的部分特性，又可以增加自己的新特征，还可以继承父类的protected和public类型的数据。</p>
<p>如果子类中出现与父类同名的成员函数，子类的同名成员会隐藏掉父类的，可以加作用域符号访问父类的成员。</p>
<p>好处：</p>
<ul>
<li>可以减少重复代码</li>
<li>从基类继承表现共性，自定义的新增成员表现个性</li>
</ul>
<h4 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h4><p>public继承</p>
<ul>
<li>父类中的公共权限到子类还是公共的</li>
<li>父类中的保护权限到子类中还是保护的</li>
<li>父类的私有成员子类访问不到</li>
</ul>
<p>protected继承</p>
<ul>
<li>父类的公共子类变保护</li>
<li>父类的保护到子类变保护</li>
<li>父类的私有成员子类访问不到</li>
</ul>
<p>private继承</p>
<ul>
<li>父类的公共成员变私有</li>
<li>父类的保护成员变私有</li>
<li>父类的私有成员子类访问不到</li>
</ul>
<p><strong>父类中所有的非静态成员都会被子类继承下去，私有成员也继承了但是被编译器隐藏了，访问不到</strong></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>多继承中如果父类出现了同名情况，子类使用的时候要加作用域。</p>
<p>经典的有菱形继承：两个派生类继承同一个基类，又有一个类用时继承这两个派生类。</p>
<p>两个父类有相同的成员名时，需要加作用域区分，但菱形继承导致数据有两份，资源浪费，可以利用虚继承解决。继承之前加virtual变为虚继承，此类称为虚基类。</p>
<h4 id="继承的构造与析构顺序"><a href="#继承的构造与析构顺序" class="headerlink" title="继承的构造与析构顺序"></a>继承的构造与析构顺序</h4><p>先构造父类，再构造子类，析构的顺序与构造相反。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性是指用一个名字定义不同的函数，这些函数执行不同但又类似的操作，这样就可以用同一个函数名调用不同内容的函数。</p>
<h4 id="静态多态和动态多态的区别"><a href="#静态多态和动态多态的区别" class="headerlink" title="静态多态和动态多态的区别"></a>静态多态和动态多态的区别</h4><ul>
<li>静态多态编译阶段确定函数地址</li>
<li>动态多态运行时确定函数地址</li>
</ul>
<h4 id="静态多态（函数重载、运算符重载）"><a href="#静态多态（函数重载、运算符重载）" class="headerlink" title="静态多态（函数重载、运算符重载）"></a>静态多态（函数重载、运算符重载）</h4><h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p>基本规则</p>
<ul>
<li>重载后运算符的优先级和结合性不会改变</li>
<li>不能改变原运算符操作数的个数</li>
<li>不能重载c++中没有的运算符</li>
<li>不能改变运算符的原有语义</li>
<li>运算符重载函数的参数至少应有一个是类对象（或类对象的引用）</li>
<li>重载函数可以是普通函数，类的成员函数或类的友元函数</li>
</ul>
<p>重载的两种方式</p>
<ul>
<li>重载为类的友元函数<ul>
<li>双目运算符、具有交换性的运算符、输入输出、左边的操作数不是类的类型。</li>
</ul>
</li>
<li>重载为类的成员函数<ul>
<li>单目运算符、需要修改类的数据，重载运算符的关键字是operator。输入输出运算符的重载必须为友元函数，且必须有输入输出流的返回值。</li>
</ul>
</li>
</ul>
<p>输入输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, 重载类名 &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,重载类名&amp;);</span><br></pre></td></tr></table></figure>

<h4 id="动态多态（派生类和虚函数实现运行时多态）"><a href="#动态多态（派生类和虚函数实现运行时多态）" class="headerlink" title="动态多态（派生类和虚函数实现运行时多态）"></a>动态多态（派生类和虚函数实现运行时多态）</h4><p>满足的条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类的虚函数</li>
</ul>
<p>使用：</p>
<ul>
<li>父类的指针或者引用，执行子类对象</li>
</ul>
<h1 id="c-概述"><a href="#c-概述" class="headerlink" title="c++概述"></a>c++概述</h1><h2 id="结构体、联合体和枚举名可以直接作为类型名"><a href="#结构体、联合体和枚举名可以直接作为类型名" class="headerlink" title="结构体、联合体和枚举名可以直接作为类型名"></a>结构体、联合体和枚举名可以直接作为类型名</h2><p>在定义变量时，前面不用加对应的关键字（struct、union、enum）</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>三种情况：</p>
<ul>
<li><p>常量指针</p>
<p>const int *p=&a;<br>指针的指向可以修改，但是指针执行的值不可以改。</p>
</li>
<li><p>指针常量<br>int *const p=&a;<br>指针的指向不能改，指向的值可以改</p>
</li>
<li><p>修饰常量<br>常量的值不能改</p>
</li>
</ul>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>局部变量在作用域内权限高于全局变量。可以用作用域运算符“::”访问全局变量。如“::a”，表示全局变量a。</p>
<p>全局变量可以一直存在，存放在全局区，局部变量使用后不保存。</p>
<h2 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h2><ol>
<li>全局静态变量</li>
</ol>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<ol start="2">
<li>局部静态变量</li>
</ol>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。</p>
<ol start="4">
<li>类的静态成员</li>
</ol>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
<ol start="5">
<li>类的静态函数</li>
</ol>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h2 id="内联函数（空间换时间）"><a href="#内联函数（空间换时间）" class="headerlink" title="内联函数（空间换时间）"></a>内联函数（空间换时间）</h2><p>函数前加inline。消除函数调用时的系统开销，提高运行速度。</p>
<p>对此函数调用是直接将代码插入到调用出，同时实参取代形参。</p>
<h3 id="与宏定义的区别"><a href="#与宏定义的区别" class="headerlink" title="与宏定义的区别"></a>与宏定义的区别</h3><p>宏定义是预编译程序对齐预处理的，它只做简单的字符置换，但是不做语法检查。使用内联函数可以保存宏定义的优点，同时不会出现副作用。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数名可以相同，提高复用性。</p>
<p>使用条件：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数的参数类型不同或者个数不同或者顺序不同</li>
</ul>
<p>注意事项：</p>
<ul>
<li>函数返回值不在参数匹配检查中，因此只有返回值类型不同，则不允许重载。</li>
<li>函数重载与带默认值的函数一起实用时，有可能引起二义性</li>
<li>函数调用时，如果给出的实参和形参类型不相符，编译器会自动做类型转换，可能导致不可识别的错误。如定义了int和long，但是传入的是float类型</li>
</ul>
<h2 id="union联合体（无名联合）"><a href="#union联合体（无名联合）" class="headerlink" title="union联合体（无名联合）"></a>union联合体（无名联合）</h2><p>用的少，一般与结构体比较，具体可百度。</p>
<ul>
<li><p>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
</li>
<li><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。</p>
</li>
<li><p>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
</li>
</ul>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><ul>
<li>new可以自动计算所要分配的内存的大小</li>
<li>new能够自动返回正确的指针类型，不用像malloc一样强制转换</li>
<li>new int [10]，分配数组大小</li>
<li>new int(初值)  分配内存的同时初始化</li>
<li>new分配失败时一般返回NULL</li>
<li>delete删除数组delete []指针变量名;</li>
<li>new分配的空间不会自动释放，需要用delete</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用的本质就是一个指针常量</p>
<p>注意事项</p>
<ul>
<li>引用必须初始化，初始化后不能更改</li>
<li>引用可以作为函数的返回值存在的</li>
<li>不要返回局部变量的引用</li>
<li>可以在函数调用时作为左值</li>
<li>引用类型和被引用的类型要一致</li>
</ul>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>对象：是描述其属性的数据及对这些数据的操作封装的统一体。把数据和操作看成一个整体。</p>
</li>
<li><p>方法：将函数定义为类的一部分或者将函数与某个对象绑定，该函数就称之为方法。</p>
</li>
<li><p>类：是实现信息封装的基础，类包含数据说明和一组操作数据的方法。类的实例是对象。 （从同类对象中抽出共性形成类。）</p>
</li>
</ul>
<p>类是对象的抽象，对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。</p>
<p>类相当于自己定义的一个新的类型，可以用来定义对象，其地位和int等的地位相同。类定义的对象的大小取决于对象数据成员所占大小</p>
<p>实例化就是通过类创建对象的过程</p>
<h2 id="类的成员函数定义和声明"><a href="#类的成员函数定义和声明" class="headerlink" title="类的成员函数定义和声明"></a>类的成员函数定义和声明</h2><p><strong>类是抽象的数据类型，不占用存储空间，因此声明中不能给数据成员赋值。</strong></p>
<p>函数写在声明内时，默认定义为内联成员函数。一般类内只声明，类外实现。</p>
<p>类外实现用：类名::函数，只有::无类名或者都无，则是普通函数。</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ul>
<li>public：类内、外都可以访问</li>
<li>protected: 内可以，外不可以，子类可以访问父类的保护内容</li>
<li>private: 内可以，外不可以，子类不能访问父类的私有内容</li>
</ul>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><ul>
<li>struct默认权限为公</li>
<li>class默认为私</li>
</ul>
<h2 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h2><ul>
<li><p>构造函数和类名相同，不能指定返回值类型可以重载</p>
</li>
<li><p>作用是在定义对象时对数据进行初始化，建立对象时自动调用，不能被用户调用。一个类只能由一个默认构造函数，类中定义了全部是默认参数的构造函数后就不能再定义重载构造函数。</p>
</li>
<li><p>析构函数是在类名前加一个~，作用是在撤销对象占用的内存之前完成一些清理工作，而非删除对象。与构造函数类似的是析构函数不返回任何值，没有函数类型，不同的是析构函数不能被重载，没有函数参数。一个类可以有多个构造函数，却只能由一个析构函数，在撤消对象占用内存前调用。</p>
</li>
</ul>
<p>析构的顺序是：先被定义的后析构。</p>
<p>其他类作为本类成员，构造时，先构造其他类的对象，再构造自身的。</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>调用有三种情况：</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p>匿名对象：Person(10);执行后系统自动清理，不要利用拷贝构造函数初始化匿名对象。</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝：简单的赋值。堆区内容容易重复释放</li>
<li>深拷贝：在堆区重新申请空间，进行拷贝操作</li>
</ul>
<p>用深拷贝解决指针悬挂问题。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>成员变量或者函数前加static。不属于某一对象，实例化对象时不为静态成员分配空间，静态数据成员是在定义时被分配空间，到程序结束时才释放空间。可以被初始化，但必须要在类外，其关键字为static。静态成员函数没有this指针，不能访问非静态数据成员，用于访问静态数据成员。</p>
<p>静态成员变量：</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<p>静态成员函数：</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
<h2 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h2><p>只有非静态成员变量才属于类的对象上吗，非静态成员函数不属于类的对象上。</p>
<h2 id="空对象的内存空间大小为1"><a href="#空对象的内存空间大小为1" class="headerlink" title="空对象的内存空间大小为1"></a>空对象的内存空间大小为1</h2><p>每个空对象也分配一个字节空间，是为了区分空对象占内存的位置，每个空对象也应该有一个独一无二的内存地址。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。</p>
<p>是隐含每一个非静态成员函数内的一种指针，不需要定义，直接使用。本质是指针常量。</p>
<p>用途：</p>
<ul>
<li>当形参和成员变量同名时，可以用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<p>当前类的对象。调用自己的构造函数</p>
<h2 id="常类型"><a href="#常类型" class="headerlink" title="常类型"></a>常类型</h2><p>常数据成员：只能通过构造函数的初始化表对常数据成员进行初始化</p>
<p>常成员函数：只能引用本类的数据成员，但不能修改</p>
<p>常对象：定义时必须同时进行初始化，且之后不能再改变，只能调用常成员函数，只能被常指针指向。</p>
<h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><ul>
<li>成员函数后加const称为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable，在常函数中依然可以修改</li>
</ul>
<h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ul>
<li>声明对象前加const称为常对象</li>
<li>常对象只能调用常函数</li>
<li>常对象的数据成员值在对象的整个生存期内不能被改变</li>
</ul>
<h2 id="友元函数（可访问对应的私有成员）"><a href="#友元函数（可访问对应的私有成员）" class="headerlink" title="友元函数（可访问对应的私有成员）"></a>友元函数（可访问对应的私有成员）</h2><p>三种实现：</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<p>在一个类的声明中加如另一个类，声明为friend，则那个类可以访问本类的私有成员，同理另一个类的成员函数可单独声明作为友元函数。</p>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><p>如果一个类有多个直接基类，这些直接基类又有共同的基类，则派生类中会保留这个间接的共同基类数据成员的多份同名成员，造成内存浪费，经典的有菱形继承。在访问这些同名的成员时，必须在派生类对象名后增加直接基类名，使其唯一的标识一个成员，以免产生二义性。</p>
<p>使公共基类只产生一个复制，则可以将基类说明为虚基类。</p>
<p>虚基类在派生类中声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span><span class="keyword">virtual</span> 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚基类的初始化"><a href="#虚基类的初始化" class="headerlink" title="虚基类的初始化"></a>虚基类的初始化</h3><ul>
<li>虚基类定义带形参的构造函数，并且没有定义默认形式的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调动，以初始化在虚基类中的数据成员</li>
<li>建立一个对象时，对象含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。</li>
<li>若同一层次中同时包含虚基类和非虚基类，应先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类构造函数。</li>
<li>对于多个虚基类，构造函数的执行顺序仍然是先左后右，自上而下</li>
<li>对于非虚基类，构造函数的执行顺序仍然是先左后右，自上而下</li>
<li>若虚基类是非虚基类派生而来，则仍然先调用基类构造函数，再调用派生类的构造函数。</li>
</ul>
<h2 id="运算符重载（编译时）"><a href="#运算符重载（编译时）" class="headerlink" title="运算符重载（编译时）"></a>运算符重载（编译时）</h2><p><strong>重载的部分注意事项在第一章介绍多态的部分</strong></p>
<h3 id="加法重载"><a href="#加法重载" class="headerlink" title="加法重载"></a>加法重载</h3><p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(Complex a1,Complex a2)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">total=a1+a2;<span class="comment">//显示调用/隐式调用,等价于total=operator+(a1,a2)</span></span><br></pre></td></tr></table></figure>

<h3 id="不能运算法重载的"><a href="#不能运算法重载的" class="headerlink" title="不能运算法重载的"></a>不能运算法重载的</h3><ul>
<li>. //成员访问运算符</li>
<li>.*成员指针访问运算符</li>
<li>:: 作用域运算符</li>
<li>suzeif长度运算符</li>
<li>?:条件运算符</li>
</ul>
<h3 id="不能定义为友元运算符重载函数的"><a href="#不能定义为友元运算符重载函数的" class="headerlink" title="不能定义为友元运算符重载函数的"></a>不能定义为友元运算符重载函数的</h3><p>=、[]、函数调用“()”</p>
<h3 id="双目运算符重载"><a href="#双目运算符重载" class="headerlink" title="双目运算符重载"></a>双目运算符重载</h3><p>成员运算符重载函数的形参表仅有一个参数，作为运算符的右操作数。通过this指针隐含传递的。</p>
<ul>
<li>aa@bb  //隐式调用</li>
<li>aa.operator@(bb)//显式调用</li>
</ul>
<h3 id="成员运算符重载函数和友元运算符重载函数的比较"><a href="#成员运算符重载函数和友元运算符重载函数的比较" class="headerlink" title="成员运算符重载函数和友元运算符重载函数的比较"></a>成员运算符重载函数和友元运算符重载函数的比较</h3><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是重载的一种表现形式。是动态的重载，运行时的多态，就是在运行时才决定如何动态，即动态联编。</p>
<p>基类的对象指针可以指向它的公有派生的对象，但是当其指向公有派生类对象时，它只能访问派生类中从基类继承来的成员，而不能访问公有派生类中定义的成员。</p>
<p>而引入虚函数，程序在运行时根据指针所指向的实际对象，调用该对象的成员函数，可以解决此类问题。</p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>c++不能声明虚构造函数，但是可以声明虚析构函数。当派生类对象撤销时，一般先调用派生类的析构函数，然后再调用基类的析构函数。</p>
<p>但是遇到指针会先撤销基类的，因此要将基类的析构函数声明为虚析构函数。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是在基类中的虚函数，在该基类中没有定义，但派生类需要定义，或仍然说明为纯虚函数。</p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名（参数表）=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>在基类中为派生类保留一个函数的名字，以便派生类根据需要对它重新定义。</p>
<p>类中含有纯虚函数，则成为抽象类。</p>
<p>抽象类的使用规定：</p>
<ul>
<li>抽象类只能用作其他类的基类，不能建立抽象类对象</li>
<li>抽象类不能用作参数类型、函数返回类型或显式转换的类型。但可以声明指向抽象类的指针变量，此指针可以指向它的派生类，进而实现多态性</li>
<li>如果抽象类的派生类没有重新说明纯虚函数，则依然是抽象类</li>
</ul>
<h1 id="模版与异常处理"><a href="#模版与异常处理" class="headerlink" title="模版与异常处理"></a>模版与异常处理</h1><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数&gt;</span><br><span class="line">返回类型 函数名（模版形参表）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以用下面这种</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 类型参数&gt;</span></span><br><span class="line"><span class="class">返回类型 函数名（模版形参表）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应的参数使用时必须要实例化</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>允许多个类型参数，参数必须加关键字typename或class</li>
<li>template与函数模版定义之间不能有别的语句</li>
<li>模版函数类似于重载函数，只不过更严格一些。同一模版函数实例化后执行相同的操作。</li>
<li>函数模版也可以重载</li>
<li>函数模版与同名的非模版函数也可以重载，先找的是非模版函数，找不到再看模版函数。</li>
</ul>
<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>定义与函数模版类似</p>
<p>使用注意：</p>
<ul>
<li>需要在成员函数定义前进行模版声明</li>
<li>在成员函数名前缀上“类名&lt;类型参数&gt;::”</li>
</ul>
<p>类模版外定义的成员函数的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数&gt;</span><br><span class="line">函数类型 类名&lt;类型参数&gt;::成员函数名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>程序运行时出现的错误称为异常。处理异常机制：try(检查)、throw(抛出)、catch(捕获)</p>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    被检查的语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型声明<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    进行异常处理的复合语句<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...)<span class="comment">//表示异常是任意类型</span></span><br><span class="line">&#123;</span><br><span class="line">    进行异常处理的复合语句<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流类库与输入输出"><a href="#流类库与输入输出" class="headerlink" title="流类库与输入输出"></a>流类库与输入输出</h1><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">OF</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;</span><br><span class="line">    OF&lt;&lt;<span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="遇过的简答"><a href="#遇过的简答" class="headerlink" title="遇过的简答"></a>遇过的简答</h1><h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p>重载实现的是编译时的多态性，重写实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。</p>
<p>定义方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名（形参表）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在基类中的成员函数被声明为虚函数，此函数可以在派生类中被重新定义。重新定义时，函数原型必须相同，即类型、名称、参数个数和顺序必须相同。</p>
<p>注意：</p>
<ul>
<li>在类内声明虚函数，类外定义时不要加virtual</li>
<li>虚函数无论被公有继承多少次，仍保持虚函数的特性</li>
<li>虚函数必须是所在类的成员函数，不能是友元函数，也不能是静态函数</li>
</ul>
<h2 id="c-比c特别的地方"><a href="#c-比c特别的地方" class="headerlink" title="c++比c特别的地方"></a>c++比c特别的地方</h2><p>设计思想上：</p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h2 id="C-C-中指针和引用的区别"><a href="#C-C-中指针和引用的区别" class="headerlink" title="C/C++ 中指针和引用的区别"></a>C/C++ 中指针和引用的区别</h2><p>1.指针有自己的一块空间，而引用只是一个别名；</p>
<p>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</p>
<p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p>
<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p>
<p>5.可以有const指针，但是没有const引用；</p>
<p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p>
<p>7.指针可以有多级指针（**p），而引用至于一级；</p>
<p>8.指针和引用使用++运算符的意义不一样；</p>
<p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<h2 id="为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h2><p>可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p>用途：调用函数和做函数的参数，比如回调函数。</p>
<h2 id="new-delete与malloc-free的区别是什么"><a href="#new-delete与malloc-free的区别是什么" class="headerlink" title="new/delete与malloc/free的区别是什么"></a>new/delete与malloc/free的区别是什么</h2><p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h2 id="C语言是怎么进行函数调用的？"><a href="#C语言是怎么进行函数调用的？" class="headerlink" title="C语言是怎么进行函数调用的？"></a>C语言是怎么进行函数调用的？</h2><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h2 id="C-如何处理返回值？"><a href="#C-如何处理返回值？" class="headerlink" title="C++如何处理返回值？"></a>C++如何处理返回值？</h2><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h2 id="fork-wait-exec函数"><a href="#fork-wait-exec函数" class="headerlink" title="fork,wait,exec函数"></a>fork,wait,exec函数</h2><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h2 id="map和set有什么区别，分别又是怎么实现的？"><a href="#map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="map和set有什么区别，分别又是怎么实现的？"></a>map和set有什么区别，分别又是怎么实现的？</h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h2 id="STL有什么基本组成"><a href="#STL有什么基本组成" class="headerlink" title="STL有什么基本组成"></a>STL有什么基本组成</h2><p>STL主要由：以下几部分组成：<br>容器迭代器仿函数算法分配器配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别"></a>vector和list的区别</h2><p>List：动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h1 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>每个进程都可以有一个主线程，并且只有一个主线程，实际上是主线程调用main函数的代码，线程可以为一个运行代码的通道，路径，我们可以自己创建多个线程。</p>
<p>为什么需要多线程，因为我们希望能够把一个任务分解成很多小的部分，各个小部分能够同时执行，而不是只能顺序的执行，以达到节省时间的目的。对于求和，把所有数据一起相加和分段求和再相加没什么区别。</p>
<p>一个线程只能join一次，多次会引发中断。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><strong>主线程和子线程之间是同步的关系，即主线程要等待子线程执行完毕才会继续向下执行，join()是一个阻塞函数</strong></p>
<h4 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h4><p>表示主线程不用等待子线程执行完毕，两者脱离关系.</p>
<h3 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h3><p>判断当前线程是否可以做join或者detach过程。</p>
<h3 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h3><ul>
<li>普通函数</li>
<li>通过类和对象</li>
<li>Lambda表达式创建线程</li>
<li>带参的方式创建线程</li>
<li>带智能指针创建线程</li>
<li>通过类的成员函数创建线程</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/04-13-c-summarize.html">c++总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">cesarz</a></p>
        <p><span>发布时间:</span>2021-04-13, 14:01:43</p>
        <p><span>最后更新:</span>2021-04-14, 22:08:49</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2021/04-13-c-summarize.html" title="c++总结">www.cesarz.com.cn/2021/04-13-c-summarize.html</a>
            <span class="copy-path" data-clipboard-text="原文: www.cesarz.com.cn/2021/04-13-c-summarize.html　　作者: cesarz" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2021/04-21-python-lib.html">
                    numpy、pandas、matplotlib总结
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2021/04-08-windows1-error-resolve.html">
                    电脑开机显示找不到grub引导（win10系统）
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象程序设计"><span class="toc-number">1.</span> <span class="toc-text">面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象和面向过程的设计的对比"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象和面向过程的设计的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象的程序设计的基本特征"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象的程序设计的基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">1.2.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">1.2.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#继承的权限"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">继承的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多继承"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承的构造与析构顺序"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">继承的构造与析构顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态性"><span class="toc-number">1.2.3.</span> <span class="toc-text">多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态多态和动态多态的区别"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">静态多态和动态多态的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态多态（函数重载、运算符重载）"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">静态多态（函数重载、运算符重载）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#运算符重载"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">运算符重载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态多态（派生类和虚函数实现运行时多态）"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">动态多态（派生类和虚函数实现运行时多态）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-概述"><span class="toc-number">2.</span> <span class="toc-text">c++概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体、联合体和枚举名可以直接作为类型名"><span class="toc-number">2.1.</span> <span class="toc-text">结构体、联合体和枚举名可以直接作为类型名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">2.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局变量和局部变量"><span class="toc-number">2.3.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static作用"><span class="toc-number">2.4.</span> <span class="toc-text">static作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数（空间换时间）"><span class="toc-number">2.5.</span> <span class="toc-text">内联函数（空间换时间）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与宏定义的区别"><span class="toc-number">2.5.1.</span> <span class="toc-text">与宏定义的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数重载"><span class="toc-number">2.6.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union联合体（无名联合）"><span class="toc-number">2.7.</span> <span class="toc-text">union联合体（无名联合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new和delete"><span class="toc-number">2.8.</span> <span class="toc-text">new和delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-number">2.9.</span> <span class="toc-text">引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和对象"><span class="toc-number">3.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员函数定义和声明"><span class="toc-number">3.2.</span> <span class="toc-text">类的成员函数定义和声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问权限"><span class="toc-number">3.3.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct和class的区别"><span class="toc-number">3.4.</span> <span class="toc-text">struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造和析构函数"><span class="toc-number">3.5.</span> <span class="toc-text">构造和析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝构造函数"><span class="toc-number">3.6.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深浅拷贝"><span class="toc-number">3.7.</span> <span class="toc-text">深浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员"><span class="toc-number">3.8.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量和成员函数分开存储"><span class="toc-number">3.9.</span> <span class="toc-text">成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空对象的内存空间大小为1"><span class="toc-number">3.10.</span> <span class="toc-text">空对象的内存空间大小为1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this指针"><span class="toc-number">3.11.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常类型"><span class="toc-number">3.12.</span> <span class="toc-text">常类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常函数"><span class="toc-number">3.12.1.</span> <span class="toc-text">常函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常对象"><span class="toc-number">3.12.2.</span> <span class="toc-text">常对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元函数（可访问对应的私有成员）"><span class="toc-number">3.13.</span> <span class="toc-text">友元函数（可访问对应的私有成员）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚基类"><span class="toc-number">3.14.</span> <span class="toc-text">虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚基类的初始化"><span class="toc-number">3.14.1.</span> <span class="toc-text">虚基类的初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符重载（编译时）"><span class="toc-number">3.15.</span> <span class="toc-text">运算符重载（编译时）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加法重载"><span class="toc-number">3.15.1.</span> <span class="toc-text">加法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能运算法重载的"><span class="toc-number">3.15.2.</span> <span class="toc-text">不能运算法重载的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能定义为友元运算符重载函数的"><span class="toc-number">3.15.3.</span> <span class="toc-text">不能定义为友元运算符重载函数的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双目运算符重载"><span class="toc-number">3.15.4.</span> <span class="toc-text">双目运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员运算符重载函数和友元运算符重载函数的比较"><span class="toc-number">3.15.5.</span> <span class="toc-text">成员运算符重载函数和友元运算符重载函数的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-number">3.16.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚析构函数"><span class="toc-number">3.17.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纯虚函数"><span class="toc-number">3.18.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模版与异常处理"><span class="toc-number">4.</span> <span class="toc-text">模版与异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数模版"><span class="toc-number">4.1.</span> <span class="toc-text">函数模版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类模版"><span class="toc-number">4.2.</span> <span class="toc-text">类模版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-number">4.3.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流类库与输入输出"><span class="toc-number">5.</span> <span class="toc-text">流类库与输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遇过的简答"><span class="toc-number">6.</span> <span class="toc-text">遇过的简答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重写和重载的区别"><span class="toc-number">6.1.</span> <span class="toc-text">重写和重载的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-比c特别的地方"><span class="toc-number">6.2.</span> <span class="toc-text">c++比c特别的地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C-中指针和引用的区别"><span class="toc-number">6.3.</span> <span class="toc-text">C/C++ 中指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><span class="toc-number">6.4.</span> <span class="toc-text">为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数指针"><span class="toc-number">6.5.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete与malloc-free的区别是什么"><span class="toc-number">6.6.</span> <span class="toc-text">new/delete与malloc/free的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言是怎么进行函数调用的？"><span class="toc-number">6.7.</span> <span class="toc-text">C语言是怎么进行函数调用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-如何处理返回值？"><span class="toc-number">6.8.</span> <span class="toc-text">C++如何处理返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-wait-exec函数"><span class="toc-number">6.9.</span> <span class="toc-text">fork,wait,exec函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map和set有什么区别，分别又是怎么实现的？"><span class="toc-number">6.10.</span> <span class="toc-text">map和set有什么区别，分别又是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL有什么基本组成"><span class="toc-number">6.11.</span> <span class="toc-text">STL有什么基本组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector和list的区别"><span class="toc-number">6.12.</span> <span class="toc-text">vector和list的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发方面"><span class="toc-number">7.</span> <span class="toc-text">开发方面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">7.1.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">7.1.1.</span> <span class="toc-text">join</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#detach"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">detach</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#joinable"><span class="toc-number">7.1.2.</span> <span class="toc-text">joinable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的方法"><span class="toc-number">7.1.3.</span> <span class="toc-text">创建线程的方法</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"true"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"c++总结　| 未来可期　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>




    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/04-21-python-lib.html" title="上一篇: numpy、pandas、matplotlib总结">
                <i class="fa icon-left-big"></i>
            </a>
        

        <a title="文章列表"><i class="fa icon-th-large"></i><i class="fa icon-right-big"></i></a>

        
            <a href="/2021/04-08-windows1-error-resolve.html" title="下一篇: 电脑开机显示找不到grub引导（win10系统）">
                <i class="fa icon-right-big"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/04-21-python-lib.html">numpy、pandas、matplotlib总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04-13-c-summarize.html">c++总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04-08-windows1-error-resolve.html">电脑开机显示找不到grub引导（win10系统）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04-11-python-packages.html">Python常用库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08-18-atom-error-resolve.html">windows 安装 Atom 失败，出现update已停止工作</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06-29-npm-error-resolve.html">npm ERR! Unexpected end of JSON input while parsing near和npm ERR! code EINTEGRITY</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05-06-college-probability.html">概率论与数理统计习题答案(第二版) 范大茵 陈永华编</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05-04-Artificial-competition.html">人工智能、大数据相关比赛信息收集</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03-13-matlab-qus1.html">matlab使用sym出现警告提示</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01-18-python-error-resolve.html">python3异常处理和断言assert使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11-27-ubuntu-skills.html">ubuntu下技巧总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10-24-cprogram1.html">根据输入的图的邻接矩阵A，判断此图的连通分量的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10-14-pycharm-error.html">安装完Pycharm，启动时碰到"failed to load jvm dll"的解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09-03-xinsheng.html">来自老学长的小小礼包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-28-online-website.html">在线学习网站集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-27-ctf-case.html">ctf案例集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-27-python-error.html">Python运行错误及解决方案汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-25-decode-script.html">CTF常用python脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-25-CTF-Tools-online.html">CTF Tools</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-16-HashPump.html">HashPump用户手册</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-15-python.html">python</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-15-Linux.html">Linux基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-14-sqlmap.html">sqlmap用户手册及实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-13-sql-injection.html">sql注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-12-CTF.html">CTF简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-12-V-REP PRO.html">V-REP PRO机器人仿真系统有趣实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-05-python实现小猪佩奇.html">python实现小猪佩奇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-03-mysql存储过程使用案例.html">mysql存储过程使用案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-28-c语言简单日历小程序.html">c语言简单日历小程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-25-markdown.html">markdown用户手册</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-20-HEXO-ALL.html">HEXO用户手册</a></li></ul>




    <script>
        
    </script>


<!--gitment 评论-->
  <div class="comments" id="comments">

	<!--汉化-->
    <!-- <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css"> -->
    <link rel="stylesheet" href="/css/gitment.css">
    <script src="/js/gitment.js"></script>
	<!-- <script src="https://billts.site/js/gitment.js"></script> -->
	<!--原型-->
	<!--
	<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
	<script src="https://imsun.github.io/gitment/dist/gitment.browser.js" type="text/javascript"></script>
	-->

<div id="gitmentContainer" style="margin-bottom: -19px;"></div>

  <style>
    .gitment-container a {
      border: none;
    }
    .comments {
      margin: 60px 0 0;padding: 0 60px;
    }
  </style>
  <script type="text/javascript">
    var gitment = new Gitment({
	  id: 'Tue Apr 13 2021 14:01:43 GMT+0800',
	  title: 'c++总结',
	  owner: 'chenzihaoww',
	  repo: 'chenzihaosay.github.io',
	  oauth: {
		client_id: '1c384ef9543948e154bf',
		client_secret: '64318568889df6956c6dcfdc27030a57f588a46a',
	  },
    })
    gitment.render('gitmentContainer')
  </script>
</div>

    <script> loadComment(); </script>


<!--gitment 评论 end-->


</div>
      <footer id="footer">
    <div class="outer">
      <div class="footer-left">
                <!-- <i class="fa fa-copyright"></i>
                2018-2021 cesarz -->
                <i class="fa icon-heart-empty animated infinite pulse" style="color:red">Welcome!</i>
            </div>
            <div class="footer-right">
                <!-- <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a> -->
                <!--Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v">Yelee</a>
                -->
                2019-2021©  <i class="fa icon-heart animated infinite pulse" style="color:red">cesarz</i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa icon-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                
            </div>
        
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.min.js"></script>



<script type="text/javascript"
  zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>




<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-121838755-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
             title: "a.article-title, .article-more-link a", 
             post: ".article-entry a[href], .copyright a[href]", 
            
            
            
            
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "欢迎再次访问" + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "欢迎访问" + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>


 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  </div>

</body>
</html>
